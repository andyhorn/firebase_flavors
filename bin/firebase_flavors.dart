import 'dart:io';

import 'package:args/args.dart';
import 'package:yaml/yaml.dart';

import 'src/get_pubspec_version.dart';
import 'src/models/arg_parser.dart';
import 'src/models/flavor_config.dart';
import 'src/models/global_config.dart';

void printUsage(ArgParser argParser) {
  print('Usage: dart firebase_flavors.dart <flags> [arguments]');
  print(argParser.usage);
}

void main(List<String> arguments) async {
  final argParser = getArgParser();

  try {
    final results = argParser.parse(arguments);
    final verbose = results.flag('verbose');

    if (results.flag('help')) {
      printUsage(argParser);
      return;
    }

    if (results.flag('version')) {
      print('firebase_flavors version: ${getPubspecVersion()}');
      return;
    }

    if (verbose) {
      print('[VERBOSE] Arguments: ${results.arguments}');
    }

    if (results.rest.isEmpty) {
      print('No arguments provided');
      printUsage(argParser);
      return;
    }

    if (results.rest.first.toLowerCase() == 'init') {
      await _init(force: results.flag('force'));
      return;
    }

    if (results.rest.first.toLowerCase() == 'configure') {
      if (results.rest.length > 2) {
        print('Invalid number of arguments');
        printUsage(argParser);
        return;
      }

      final flavors = results.rest.length == 1
          ? const <String>[]
          : results.rest[1].split(',').map((e) => e.trim()).toList();

      await _configure(flavors);
      return;
    }
  } on FormatException catch (e) {
    // Print usage information if an invalid argument was provided.
    print(e.message);
    print('');
    printUsage(argParser);
  }
}

Future<void> _init({bool force = false}) async {
  final yamlFile = File('firebase_flavors.yaml');

  if (yamlFile.existsSync() && !force) {
    stderr.writeln(
      'firebase_flavors.yaml already exists.\n'
      'Use `firebase_flavor_tool init --force` to overwrite.',
    );
    exit(1);
  }

  final gradleFile = _getGradleFile();
  final detectedFlavors = <String>{};

  String? detectedBaseAppId;

  if (gradleFile != null) {
    final text = gradleFile.readAsStringSync();

    // Find productFlavors block and extract flavor names like "dev {", "staging {" etc.
    final flavorsBlock = RegExp(
      r'productFlavors\s*{([^}]*)}',
      dotAll: true,
    ).firstMatch(text);

    if (flavorsBlock != null) {
      final body = flavorsBlock.group(1)!;
      final flavorNameRegex = RegExp(r'\b([A-Za-z0-9_]+)\s*{');
      for (final match in flavorNameRegex.allMatches(body)) {
        detectedFlavors.add(match.group(1)!);
      }
    }

    // Try to find an applicationId "com.example.app" somewhere.
    final appIdMatch = RegExp(r'applicationId\s+"([^"]+)"').firstMatch(text);
    if (appIdMatch != null) {
      detectedBaseAppId = appIdMatch.group(1);
    }
  }

  // 2) Decide on flavors.
  // If we detected flavors, use those; otherwise default to dev/staging/prod.
  final List<String> flavors;
  if (detectedFlavors.isNotEmpty) {
    flavors = detectedFlavors.toList();
  } else {
    flavors = ['dev', 'staging', 'prod'];
  }

  // 3) Decide on base bundle id.
  // If we detected something, use that; otherwise put a placeholder.
  final baseBundleId = detectedBaseAppId ?? 'com.example.app';

  // 4) Build YAML content.
  final buffer = StringBuffer();

  buffer.writeln(
    '# Firebase flavor configuration generated by firebase_flavor_tool init',
  );
  buffer.writeln('# Review and edit as needed.');
  buffer.writeln('');
  buffer.writeln('appName: your_app_name_here');
  buffer.writeln('baseBundleId: $baseBundleId');
  buffer.writeln('');
  buffer.writeln('android:');
  buffer.writeln('  srcBase: android/app/src');
  buffer.writeln('');
  buffer.writeln('ios:');
  buffer.writeln('  xcodeprojPath: ios/Runner.xcodeproj');
  buffer.writeln('  target: Runner');
  buffer.writeln('  configBase: ios/Runner/Config');
  buffer.writeln('');
  buffer.writeln('flavors:');

  for (final flavor in flavors) {
    final isProdLike =
        flavor.toLowerCase() == 'prod' || flavor.toLowerCase() == 'production';
    final suffix = isProdLike ? '' : '.$flavor';
    final optionsOut = 'lib/firebase_options_$flavor.dart';
    final androidSrcDir = flavor;
    final iosConfigDir = flavor;

    buffer.writeln('  $flavor:');
    buffer.writeln(
      '    firebaseProjectId: your-firebase-project-id-for-$flavor',
    );
    buffer.writeln('    androidPackageSuffix: $suffix');
    buffer.writeln('    dartOptionsOut: $optionsOut');
    buffer.writeln('    androidSrcDir: $androidSrcDir');
    buffer.writeln('    iosConfigDir: $iosConfigDir');
    buffer.writeln('    # Optional: override iOS bundle ID for this flavor.');
    buffer.writeln('    # iosBundleId: com.example.app.$flavor');
    buffer.writeln('    iosBuildConfigs:');
    buffer.writeln('      - Debug-$flavor');
    buffer.writeln('      - Release-$flavor');
    buffer.writeln('      - Profile-$flavor');
    buffer.writeln('');
  }

  yamlFile.writeAsStringSync(buffer.toString());

  print('Created firebase_flavors.yaml âœ…');
  print('Detected flavors: ${flavors.join(', ')}');
  if (detectedBaseAppId != null) {
    print('Detected base bundle ID from Android: $detectedBaseAppId');
  } else {
    print(
      'Base bundle ID defaulted to $baseBundleId (edit this in firebase_flavors.yaml).',
    );
  }
}

File? _getGradleFile() {
  final f = File('android/app/build.gradle');
  if (f.existsSync()) return f;
  final kts = File('android/app/build.gradle.kts');
  if (kts.existsSync()) return kts;
  return null;
}

Future<void> _configure(List<String> flavors) async {
  final config = _readConfig();

  if (flavors.isEmpty) {
    flavors.addAll(config.flavors.keys);
  }

  for (final flavor in flavors) {
    if (!config.flavors.containsKey(flavor)) {
      print('Flavor $flavor not found');
      continue;
    }

    await _configureFlavor(config, config.flavors[flavor]!);
  }
}

GlobalConfig _readConfig() {
  final file = File('firebase_flavors.yaml');
  final content = file.readAsStringSync();
  final yaml = loadYaml(content) as Map<String, dynamic>;

  return GlobalConfig.fromMap(yaml);
}

Future<void> _configureFlavor(
  GlobalConfig config,
  FlavorConfig flavorConfig,
) async {
  Process.run('flutterfire', [
    'configure',
    '--project=${flavorConfig.firebaseProjectId}',
    '--out=${flavorConfig.dartOptionsOut}',
    if (flavorConfig.platforms?.isNotEmpty ?? false) ...[
      '--platforms=${flavorConfig.platforms}',
    ],
    '--android-package-name=${config.baseBundleId}${flavorConfig.androidPackageSuffix}',
    '--android-out=${flavorConfig.androidSrcDir}/google-services.json',
    '--ios-bundle-id=${config.baseBundleId}',
    '--ios-out=${flavorConfig.iosConfigDir}/GoogleService-Info.plist',
    '--yes',
  ]);
}
